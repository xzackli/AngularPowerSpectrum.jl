var documenterSearchIndex = {"docs":
[{"location":"module_index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"module_index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"module_index/","page":"Index","title":"Index","text":"Modules = [PowerSpectra]","category":"page"},{"location":"module_index/#PowerSpectra.ConstantDict","page":"Index","title":"PowerSpectra.ConstantDict","text":"A dictionary that always returns one thing, no matter what key.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#PowerSpectra.CovarianceWorkspace-Union{Tuple{T}, NTuple{4, CovField{T}}} where T","page":"Index","title":"PowerSpectra.CovarianceWorkspace","text":"CovarianceWorkspace(m_i, m_j, m_p, m_q; lmax::Int=0)\n\nInputs and cache for covariance calculations. A covariance matrix relates the masks of four fields and spins. This structure caches various cross-spectra between masks and noise-weighted masks.\n\nArguments:\n\nm_i::CovField{T}: map i\nm_j::CovField{T}: map j\nm_p::CovField{T}: map p\nm_q::CovField{T}: map q\n\nKeywords\n\nlmax::Int=0: maximum multipole to compute covariance matrix\n\n\n\n\n\n","category":"method"},{"location":"module_index/#PowerSpectra.SpectralArray-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Index","title":"PowerSpectra.SpectralArray","text":"SpectralArray(A::AbstractArray, [ranges])\n\nA renamed OffsetArray. By default, it produces a 0-indexed array.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#PowerSpectra.SpectralVector-Tuple{AbstractVector}","page":"Index","title":"PowerSpectra.SpectralVector","text":"Alias for SpectralArray{T,1}\n\n\n\n\n\n","category":"method"},{"location":"module_index/#PowerSpectra.coupledcov-Union{Tuple{T}, Tuple{Symbol, Symbol, CovarianceWorkspace{T}, AbstractDict}, Tuple{Symbol, Symbol, CovarianceWorkspace{T}, AbstractDict, AbstractDict}} where T","page":"Index","title":"PowerSpectra.coupledcov","text":"coupledcov(ch1, ch2, workspace, spectra;\n           noiseratios=Dict(), lmax=0) where T\n\nArguments:\n\nch1::Symbol: spectrum type of first spectrum (i.e. :TT, :TE, :EE)\nch2::Symbol: spectrum type of second spectrum (i.e. :TT, :TE, :EE)\nworkspace: cache for working with covariances\nspectra: signal spectra\n\nKeywords\n\nnoiseratios::AbstractDict: ratio of noise spectra to white noise\nlmax=0: maximum multipole moment for covariance matrix\n\nReturns:\n\nSpectralArray{T,2}: covariance matrix (0-indexed)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#PowerSpectra.decouple_covmat-Union{Tuple{SA}, Tuple{T}, Tuple{SA, SA, SA}} where {T, SA<:(SpectralArray{T, 2})}","page":"Index","title":"PowerSpectra.decouple_covmat","text":"decouple_covmat(Y, B1, B2; lmin1=2, lmin2=2)\n\nDecouples a covariance matrix Y, performing B₁⁻¹ × Y × (B₂⁻¹)^† by mutating Y. \n\n\n\n\n\n","category":"method"},{"location":"module_index/#PowerSpectra.fitdipole","page":"Index","title":"PowerSpectra.fitdipole","text":"function fitdipole(m::HealpixMap{T}, [w::HealpixMap{T}=1]) where T\n\nFit the monopole and dipole of a map. \n\nArguments:\n\nm::HealpixMap{T}: map to fit\nw::HealpixMap{T}: weight map. Defaults to a FillArray of ones.\n\nReturns:\n\nTuple{T, NTuple{3,T}}: (monopole, (dipole x, dipole y, dipole z))\n\n\n\n\n\n","category":"function"},{"location":"module_index/#PowerSpectra.getblock-Union{Tuple{M_BLOCKS}, Tuple{T}, Tuple{BlockSpectralMatrix{T, M_BLOCKS, 1}, Int64}} where {T, M_BLOCKS}","page":"Index","title":"PowerSpectra.getblock","text":"getblock(A::BlockSpectralMatrix{T,M_BLOCKS,1}, i) where {T,M_BLOCKS}\n\nExtract a sub-block from a BlockSpectralMatrix.\n\nArguments:\n\nA::BlockSpectralMatrix{T,M_BLOCKS,1}: array to extract from\ni::Int: index of the sub-block (1-indexed)\n\nReturns:\n\nArray{T,2}: sub-blocks\n\n\n\n\n\n","category":"method"},{"location":"module_index/#PowerSpectra.kᵤ-Tuple{Type, Any}","page":"Index","title":"PowerSpectra.kᵤ","text":"kᵤ([T=Float64], u)\n\nDefined only for u ∈ {-2, 0, 2}.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#PowerSpectra.mask!-Tuple{Healpix.HealpixMap, Any}","page":"Index","title":"PowerSpectra.mask!","text":"mask!(m::HealpixMap, mask)\nmask!(m::PolarizedHealpixMap, maskT, maskP)\n\nMask a map or polarized map in place.\n\nArguments:\n\nm::Union{HealpixMap,PolarizedHealpixMap}: map or polarized map to mask\nmaskT::HealpixMap: mask for first map's intensity\nmaskP::HealpixMap: mask for first map's polarization\n\n\n\n\n\n","category":"method"},{"location":"module_index/#PowerSpectra.maskedalm2spectra-Union{Tuple{A}, Tuple{CT}, Tuple{Vector{A}, A, A, Vector{A}, A, A}} where {CT, A<:(Healpix.Alm{CT, AA} where AA<:AbstractVector{CT})}","page":"Index","title":"PowerSpectra.maskedalm2spectra","text":"Compute spectra from alms of masked maps and alms of the masks themselves.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#PowerSpectra.master-Tuple{Healpix.PolarizedHealpixMap, Healpix.HealpixMap, Healpix.HealpixMap, Healpix.PolarizedHealpixMap, Healpix.HealpixMap, Healpix.HealpixMap}","page":"Index","title":"PowerSpectra.master","text":"master(map₁::PolarizedHealpixMap, maskT₁::HealpixMap, maskP₁::HealpixMap,\n       map₂::PolarizedHealpixMap, maskT₂::HealpixMap, maskP₂::HealpixMap; already_masked=false)\n\nPerform a mode-decoupling calculation for two polarized maps, along with masks to apply. Returns spectra for TT, TE, ET, EE, EB, BE, and BB.\n\nArguments:\n\nmap₁::PolarizedHealpixMap: the first IQU map\nmaskT₁::HealpixMap: mask for first map's intensity\nmaskP₁::HealpixMap: mask for first map's polarization\nmap₂::PolarizedHealpixMap: the second IQU map\nmaskT₂::HealpixMap: mask for second map's intensity\nmaskP₂::HealpixMap: mask for second map's polarization\n\nKeywords\n\nalready_masked::Bool=false: are the input maps already multiplied with the masks?\nlmin::Int=0: minimum multipole\n\nReturns:\n\nDict{Symbol,SpectralVector}: spectra Dict, indexed with :TT, :TE, :ET, etc.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#PowerSpectra.mcm-Union{Tuple{T}, Tuple{Symbol, Healpix.Alm{Complex{T}, AA} where AA<:AbstractArray{Complex{T}, 1}, Healpix.Alm{Complex{T}, AA} where AA<:AbstractArray{Complex{T}, 1}}} where T","page":"Index","title":"PowerSpectra.mcm","text":"mcm(spec::Symbol, alm₁::Alm{T}, alm₂::Alm{T}; lmax=nothing)\n\nCompute the mode-coupling matrix. See the Spectral Analysis section in the documentation for examples. These are used by applying the  linear solve operator \\ to a SpectralArray{T,1}.\n\nChoices for spec:\n\n:TT, identical to M⁰⁰\n:TE, identical to :ET, :TB, :BT, :M⁰², :M²⁰\n:EE_BB, returns coupling matrix for stacked EE and BB vectors\n:EB_BE, returns coupling matrix for stacked EB and BE vectors\n:M⁺⁺, sub-block of spin-2 mode-coupling matrices\n:M⁻⁻, sub-block of spin-2 mode-coupling matrices\n\nArguments:\n\nspec::Symbol: cross-spectrum of the mode-coupling matrix\nalm₁::Alm{T}: first mask's spherical harmonic coefficients\nalm₂::Alm{T}: second mask's spherical harmonic coefficients\n\nKeywords\n\nlmin=0: minimum multiple for mode-coupling matrix\nlmax=nothing: maximum multipole for mode-coupling matrix\n\nReturns:\n\nthe mode coupling matrix. for single symbols, this returns a    SpectralArray{T,2}. if spec is :EE_BB or :EB_BE, returns a    BlockSpectralMatrix{T} with 2×2 blocks.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#PowerSpectra.name_alms-Tuple{Vector}","page":"Index","title":"PowerSpectra.name_alms","text":"Construct a NamedTuple with T,E,B names for the alms.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#PowerSpectra.nside2lmax-Tuple{Any}","page":"Index","title":"PowerSpectra.nside2lmax","text":"nside2lmax(nside)\n\nGet the Nyquist frequency from nside, 3n_mathrmside - 1.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#PowerSpectra.planck256_map","page":"Index","title":"PowerSpectra.planck256_map","text":"planck256_map(freq, split, col, type::Type=Float64) -> HealpixMap{T, RingOrder}\n\nReturns a Planck 2018 half-mission frequency map downgraded to nside 256 in KCMB units. FITS file column numbers are \n\nI_STOKES\nQ_STOKES\nU_STOKES\nHITS\nII_COV\nIQ_COV\nIU_COV\nQQ_COV\nQU_COV\nUU_COV\n\nArguments:\n\nfreq::String: Planck frequency ∈ {\"100\", \"143\", \"217\"}\nsplit::String: half mission split ∈ {\"hm1\", \"hm2\"}\ncol::Int: FITS file column. Either a number, String, or Symbol above. \n\nReturns:\n\nMap{T, RingOrder}: the map\n\n\n\n\n\n","category":"function"},{"location":"module_index/#PowerSpectra.planck256_mask","page":"Index","title":"PowerSpectra.planck256_mask","text":"planck256_mask(freq, split, maptype, T::Type=Float64) -> HealpixMap{T}\n\nArguments:\n\nfreq::String: Planck frequency ∈ {\"100\", \"143\", \"217\"}\nsplit::String: half mission split ∈ {\"hm1\", \"hm2\"}\nmaptype: pass T or P, as a String or Symbol  \n\nReturns:\n\nHealpixMap{T, RingOrder}: the mask\n\n\n\n\n\n","category":"function"},{"location":"module_index/#PowerSpectra.quickpolW-Union{Tuple{T}, Tuple{Healpix.Alm{Complex{T}, AA} where AA<:AbstractArray{Complex{T}, 1}, Healpix.Alm{Complex{T}, AA} where AA<:AbstractArray{Complex{T}, 1}}} where T<:Number","page":"Index","title":"PowerSpectra.quickpolW","text":"quickpolW(alm₁::Alm{Complex{T}}, alm₂::Alm{Complex{T}})\n\nComputes a scaled spectrum of the scan pattern.\n\nW_ell^nu_1nu_2s_1s_2j_1j_2 = sum_m^prime=-ell^prime^ell^prime\n    left(_s_1+nu_1tildeomega^(j_1)_ell^prime m^primeright)\n    left(_s_2+nu_2tildeomega^(j_2)_ell^prime m^primeright)^*\n\n\n\n\n\n","category":"method"},{"location":"module_index/#PowerSpectra.quickpolΞ!-Union{Tuple{AA}, Tuple{T}, Tuple{AA, Any, Any, Any, Any, Healpix.Alm, Healpix.Alm, Array{Vector{T}, 1}, Array{Vector{T}, 1}}} where {T, AA<:(SpectralArray{T, 2})}","page":"Index","title":"PowerSpectra.quickpolΞ!","text":"quickpolΞ!(𝚵::AA, ν₁, ν₂, s₁, s₂, ω₁, ω₂)\n\nThis computes the Xi_ell^prime primeell matrix. It assumes rho has been absorbed into the omega terms.\n\nω₁: effective scan weights with spin s₁ + ν₁\nω₂: effective scan weights with spin s₂ + ν₂\n\n\n\n\n\n","category":"method"},{"location":"module_index/#PowerSpectra.scale!-Tuple{Healpix.HealpixMap, Number}","page":"Index","title":"PowerSpectra.scale!","text":"Scale a map.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#PowerSpectra.spectralones-Tuple{Vararg{Int64}}","page":"Index","title":"PowerSpectra.spectralones","text":"spectralones(size1::Int, size2::Int, ...)\nspectralones(range1::AbstractRange, range2::AbstractRange, ...)\n\nUtility function for generating a SpectralArray by passing arguments of ranges or sizes, just like ones.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#PowerSpectra.spectralzeros-Tuple{Vararg{Int64}}","page":"Index","title":"PowerSpectra.spectralzeros","text":"spectralzeros(size1, size2, ...)\nspectralzeros(range1, range2, ...)\n\nUtility function for generating a SpectralArray by passing arguments of ranges or sizes, just like zeros.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#PowerSpectra.subtract_monopole_dipole!-Union{Tuple{T}, Tuple{Healpix.HealpixMap, T, Tuple{T, T, T}}} where T","page":"Index","title":"PowerSpectra.subtract_monopole_dipole!","text":"subtract_monopole_dipole!(map_in, monopole, dipole)\n\nArguments:\n\nmap_in::HealpixMap: the map to modify\nmonopole::T: monopole value\ndipole::NTuple{3,T}: dipole value\n\n\n\n\n\n","category":"method"},{"location":"module_index/#PowerSpectra.synalm!-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractArray{T, 3}, Vector}} where T","page":"Index","title":"PowerSpectra.synalm!","text":"synalm!([rng=GLOBAL_RNG], Cl::AbstractArray{T,3}, alms::Vector{Alm{Complex{T}}}) where T\n\nIn-place synthesis of spherical harmonic coefficients, given spectra.\n\nArguments:\n\nCl::AbstractArray{T,3}: array with dimensions of comp, comp, ℓ\nalms::Vector: array of Alm to fill\n\nExamples\n\nnside = 16\nC0 = [3.  2.;  2.  5.]\nCl = repeat(C0, 1, 1, 3nside)  # spectra constant with ℓ\nalms = [Alm{Complex{Float64}}(3nside-1, 3nside-1) for i in 1:2]\nsynalm!(Cl, alms)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#PowerSpectra.synalm-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractArray{T, 3}, Int64}} where T","page":"Index","title":"PowerSpectra.synalm","text":"synalm([rng=GLOBAL_RNG], Cl::AbstractArray{T,3}, nside::Int) where T\n\nArguments:\n\nCl::AbstractArray{T,3}: array with dimensions of comp, comp, ℓ\nnside::Int: healpix resolution\n\nReturns:\n\nVector{Alm{T}}: spherical harmonics realizations for each component\n\nExamples\n\nnside = 16\nC0 = [3.  2.;  2.  5.]\nCl = repeat(C0, 1, 1, 3nside)  # spectra constant with ℓ\nalms = synalm(Cl, nside)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#PowerSpectra.Ξsum-Union{Tuple{T}, Tuple{SpectralVector{T}, WignerFamilies.WignerSymbolVector{T, Int64, AA} where AA<:AbstractVector{T}, WignerFamilies.WignerSymbolVector{T, Int64, AA} where AA<:AbstractVector{T}}} where T<:Number","page":"Index","title":"PowerSpectra.Ξsum","text":"Ξsum(alm₁, alm₂, w3j₁, w3j₂)\n\nSum over ell and m of two a_ell m and nontrivial Wigner-3j vectors. This is a step in computing the mathbfXi matrix. The rho factors are not in this summation, as they can be pulled out.\n\nbeginaligned\n(Xi mathrmsum) = sum_ell^prime m^prime   W_ell^nu_1nu_2s_1s_2j_1j_2 times beginpmatrix ell  ell^prime  ell^primeprime \n     -s_1  s_1+nu_1   -nu_1 endpmatrix beginpmatrix\n     ell  ell^prime  ell^primeprime  -s_2  s_2+nu_2   -nu_2 endpmatrix\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"module_index/#PowerSpectra.@spectra-Tuple{Any}","page":"Index","title":"PowerSpectra.@spectra","text":"@spectra [expr=BlockSpectralMatrix]\n\nUnpack a block vector. This is equivalent to calling getblock for all the  sub-blocks and putting them in a Tuple. \n\nExample\n\n# compute stacked EE,BB mode-coupling matrix from mask alm\nM_EE_BB = mcm(:EE_BB, map2alm(mask1), map2alm(mask2))\n# apply the 2×2 block mode-coupling matrix to the stacked EE and BB spectra\n@spectra Cl_EE, Cl_BB = M_EE_BB \\ [pCl_EE; pCl_BB]\n\n\n\n\n\n","category":"macro"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"CurrentModule = PowerSpectra","category":"page"},{"location":"spectra/#Spectral-Analysis","page":"Spectra","title":"Spectral Analysis","text":"","category":"section"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"In this section, we describe how one can estimate unbiased cross-spectra from masked maps using this package. We expand fluctuations on the sphere in terms of spherical harmonics, with coefficients ","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"a_ell m = iint Theta(mathbfhatn) Y_ell m^* (mathbfhatn)  dOmega","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"We then define the power spectrum C_ell of these fluctuations,","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"langle a_ell m^X a_ell^prime m^prime^Y* rangle = delta_ell ell^prime delta_m m^prime C_ell","category":"page"},{"location":"spectra/#Mode-Coupling-for-TT,-TE,-TB","page":"Spectra","title":"Mode Coupling for TT, TE, TB","text":"","category":"section"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"If you compute the cross-spectrum of masked maps, the mask will couple together different modes ell_1 ell_2. This biased estimate of the true spectrum is termed the pseudo-spectrum widetildeC_ell, ","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"widetildeC_ell = frac12ell+1 sum_m mathsfm^iX_ell m mathsfm^jY_ell m","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"where mathsfm^iX_ell m are the spherical harmonic coefficients of the masked map i of channel X in T E B. In the pseudo-C_ell method, we seek an estimate hatC_ell of the true spectrum that is related to the pseudo-spectrum by a linear operator,","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"   langlewidetildeC_ellrangle = mathbfM^XY(ij)_ell_1 ell_2 langle C_ell rangle","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"where mathbfM^XY(ij)_ell_1 ell_2 is the mode-coupling matrix between fields i and j for spectrum XY. The expectation value langle cdots rangle in this expression is over all realizations of a_ell m, since the mask is not isotropic. Applying the inverse of the mode-coupling matrix to the pseudo-spectrum widetildeC_ell yields an unbiased and nearly optimal estimate hatC_ell of the true spectrum. To compute the mode-coupling matrix, one needs","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"XY, the desired spectrum, i.e. TE\nmathsfm^iX_ell m, spherical harmonic coefficients of the mask for map i, mode X\nmathsfm^jY_ell m, spherical harmonic coefficients of the mask for map j, mode Y","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"A basic functionality of this package is to compute this matrix. Let's look at a basic example of the cross-spectrum between two intensity maps.","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"# get some example masks\nusing Healpix, PowerSpectra\nmask1 = readMapFromFITS(\"test/data/mask1_T.fits\", 1, Float64)\nmask2 = readMapFromFITS(\"test/data/mask2_T.fits\", 1, Float64)\n\n# compute TT mode-coupling matrix from mask harmonic coefficients\nM = mcm(:TT, map2alm(mask1), map2alm(mask2))","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"Similarly, one could have specified the symbol :TE, :TE, or :ET for other types of cross-spectra[1]. The function mcm returns a SpectralArray{T,2}, which is an array type that contains elements in ell_mathrmmin leq ell_1 ell_2 leq ell_mathrmmax. The important thing about SpectralArray is that indices correspond to ell, such that M[ℓ₁, ℓ₂] corresponds to the mode-coupling matrix entry mathbfM_ell_1 ell_2. If you want to access the underlying array, you can use parent(mcm).. One can optionally truncate the computation with the lmax keyword, i.e. mcm(:TT, mask1, mask2; lmin=2, lmax=10). ","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"[1]: You can combine symbols, in cases where you're looping over combinations of spectra, by using Symbol.julia> Symbol(:T, :T)\n:TT","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"Now one can apply a linear solve to decouple the mask. We apply the linear solve operator Cl = M \\ pCl to perform mode decoupling on SpectralArray and SpectralVector. Here's an example that uses the mode-coupling matrix from above to obtain spectra from masked maps.","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"# generate two uniform maps\nnside = mask1.resolution.nside\nnpix = nside2npix(nside)\nmap1 = HealpixMap{Float64, RingOrder}(ones(npix))\nmap2 = HealpixMap{Float64, RingOrder}(ones(npix))\n\n# mask the maps with different masks\nmap1.pixels .*= mask1.pixels\nmap2.pixels .*= mask2.pixels\n\n# compute the pseudo-spectrum, and wrap it in a SpectralVector\nalm1, alm2 = map2alm(map1), map2alm(map2)\npCl = SpectralVector(alm2cl(alm1, alm2))\n\n# decouple the spectrum\nCl = M \\ pCl","category":"page"},{"location":"spectra/#Custom-Multipole-Ranges","page":"Spectra","title":"Custom Multipole Ranges","text":"","category":"section"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"The majority of the time, you want ell_mathrmmin=0, and you should subtract the monopole and dipole from your maps. Note that you can pass lmin to mcm. Most other mode-coupling codes start the mode-coupling calculation at ell_mathrmmin = 2. In order to imitate this behavior, you must specify lmin=2 and truncate the SpectralVector to remove the monopole and dipole.","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"using IdentityRanges  # range for preserving SpectralArrays index info in slices\npCl = SpectralVector(alm2cl(alm1, alm2))[IdentityRange(2:end)]  # start at dipole\nM = mcm(:TT, map2alm(mask1), map2alm(mask2); lmin=2)            # start at dipole\nCl = M \\ pCl  # SpectralArray with indices 2:end","category":"page"},{"location":"spectra/#Mode-Coupling-for-EE,-EB,-BB","page":"Spectra","title":"Mode Coupling for EE, EB, BB","text":"","category":"section"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"The mode coupling on spin-2 times spin-2 (:EE, :EB, :BB) is slightly more complicated. For a more detailed description, please see Thibaut Louis's notes.","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"tiny\n beginbmatrix \n langle widetildeC^T_nu_1T_nu_2_ell_1 rangle cr\n  langle widetildeC^T_nu_1E_nu_2_ell_1 rangle cr \n  langle widetildeC^T_nu_1B_nu_2_ell_1 rangle  cr \n  langle widetildeC^E_nu_1T_nu_2_ell_1 rangle  cr \n  langle widetildeC^B_nu_1T_nu_2_ell_1 rangle  cr \n  langle widetildeC^E_nu_1E_nu_2_ell_1 rangle  cr \n  langle widetildeC^B_nu_1B_nu_2_ell_1 rangle cr\n  langle widetildeC^E_nu_1B_nu_2_ell_1 rangle cr  \n  langle widetildeC^B_nu_1E_nu_2_ell_1 rangle \n  endbmatrix = sum_ell_2\nbeginbmatrix \nmathbfM^nu_1nu_200_ell_1 ell_2  0  0  0  0  0  0  0  0 \ncr\n0  mathbfM^nu_1nu_202_ell_1 ell_2  0  0  0  0  0  0  0  \ncr\n0  0  mathbfM^nu_1nu_202_ell_1 ell_2  0  0  0  0  0  0 \ncr\n0  0  0  mathbfM^nu_1nu_202_ell_1 ell_2  0  0  0  0  0 \ncr\n0  0   0  0  mathbfM^nu_1nu_202_ell_1 ell_2  0  0  0  0 \ncr\n0  0  0  0  0  mathbfM^nu_1nu_2++_ell_1 ell_2  mathbfM^nu_1nu_2--_ell_1 ell_2  0  0 \ncr\n0  0  0  0  0  mathbfM^nu_1nu_2--_ell_1 ell_2  mathbfM^nu_1nu_2++_ell_1 ell_2  0  0 \ncr\n0 0 0 0  0  0  0  mathbfM^nu_1nu_2++_ell_1 ell_2   -mathbfM^nu_1nu_2--_ell_1 ell_2  \ncr\n0  0  0  0  0  0  0  -mathbfM^nu_1nu_2--_ell_1 ell_2  mathbfM^nu_1nu_2++_ell_1 ell_2 \nendbmatrix\nbeginbmatrix langle C^T_nu_1T_nu_2_ell_2 rangle  cr langle C^T_nu_1E_nu_2_ell_2 rangle  cr langle C^T_nu_1B_nu_2_ell_2 rangle  cr langle C^E_nu_1T_nu_2_ell_2 rangle  cr langle C^B_nu_1T_nu_2_ell_2 rangle  cr \nlangle C^E_nu_1E_nu_2_ell_2 rangle  cr \nlangle C^B_nu_1B_nu_2_ell_2 rangle cr\nlangle C^E_nu_1B_nu_2_ell_2 rangle cr  \nlangle C^B_nu_1E_nu_2_ell_2 rangle  \nendbmatrix","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"Note that the (00), (02), and (20) combinations from the previous section are block-diagonal. Thus we define ","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"beginaligned\n    mathbfM^nu_1 nu_2 TT_ell_1 ell_2 = mathbfM^nu_1 nu_2 00_ell_1 ell_2 \n    mathbfM^nu_1 nu_2 TE_ell_1 ell_2 = mathbfM^nu_1 nu_2 TB_ell_1 ell_2 = mathbfM^nu_1 nu_2 02_ell_1 ell_2 \n    mathbfM^nu_1 nu_2 ET_ell_1 ell_2 = mathbfM^nu_1 nu_2 BT_ell_1 ell_2 = mathbfM^nu_1 nu_2 20_ell_1 ell_2\nendaligned","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"The previous section showed how to compute these matrices, by passing :TT, :TE, :TB, :ET, or :BT to mcm. We now define two additional block matrices,","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"mathbfM^nu_1 nu_2 EEBB_ell_1 ell_2 = left\nbeginarraycc\nmathbfM^nu_1nu_2++_ell_1 ell_2  mathbfM^nu_1nu_2--_ell_1 ell_2 \n mathbfM^nu_1nu_2--_ell_1 ell_2  mathbfM^nu_1nu_2++_ell_1 ell_2 \nendarray right qquad\nmathbfM^nu_1 nu_2 EBBE_ell_1 ell_2 = left\nbeginarraycc\nmathbfM^nu_1nu_2++_ell_1 ell_2   -mathbfM^nu_1nu_2--_ell_1 ell_2 \n-mathbfM^nu_1nu_2--_ell_1 ell_2  mathbfM^nu_1nu_2++_ell_1 ell_2  \nendarray\nright","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"These matrices are defined such that","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"left\nbeginarrayc\nlangle widetildeC^E_nu_1E_nu_2_ell_1 rangle  \nlangle widetildeC^B_nu_1B_nu_2_ell_1 rangle \nendarray\nright = sum_ell_2 mathbfM^nu_1 nu_2 EEBB_ell_1 ell_2 left\nbeginarrayc\nlangle C^E_nu_1E_nu_2_ell_2 rangle  \nlangle C^B_nu_1B_nu_2_ell_2 rangle \nendarray\nright","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"left\nbeginarrayc\nlangle widetildeC^E_nu_1B_nu_2_ell_1 rangle  \nlangle widetildeC^B_nu_1E_nu_2_ell_1 rangle \nendarray\nright = sum_ell_2 mathbfM^nu_1 nu_2 EBBE_ell_1 ell_2 left\nbeginarrayc\nlangle C^E_nu_1B_nu_2_ell_2 rangle  \nlangle C^B_nu_1E_nu_2_ell_2 rangle \nendarray\nright","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"You can compute these matrices by passing :EE_BB and :EB_BE as the first argument to mcm.  For these coupled channels, the @spectra macro can be helpful for writing clear and concise code. It unpacks the blocks of the resulting block-vector[2] after mode decoupling. The matrix syntax in Julia performs concatenation when the inputs are arrays, so [pCl_EE; pCl_BB] stacks the coupled spectra vectors vertically.","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"# compute stacked EE,BB mode-coupling matrix from mask alm\nM_EE_BB = mcm(:EE_BB, alm1, alm2)\n\n# make up some coupled pseudo-spectra\npCl_EE, pCl_BB = pCl, pCl\n\n# apply the 2×2 block mode-coupling matrix to the stacked EE and BB spectra\n@spectra Cl_EE, Cl_BB = M_EE_BB \\ [pCl_EE; pCl_BB]","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"In this case, M_EE_BB is a big matrix with blocks corresponding to mathbfM^nu_1nu_2++_ell_1 ell_2 and mathbfM^nu_1nu_2--_ell_1 ell_2. mcm wraps that matrix in a special Array type that keeps tracks of indices and blocks, which is used to unpack the results.","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"You can produce both matrices at once by passing a Tuple, (:EE_BB, :EB_BE) and get back a tuple containing the two matrices, which can be efficient since the these two block matrices share the same blocks. ","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"M_EE_BB, M_EB_BE = mcm((:EE_BB, :EB_BE), alm1, alm2)","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"You can also obtain the sub-blocks mathbfM^nu_1nu_2++_ell_1 ell_2 and mathbfM^nu_1nu_2--_ell_1 ell_2 by passing to mcm the symbols :M⁺⁺ and :M⁻⁻ (note the Unicode superscripts). ","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"[2]: The @spectra macro used there is equivalent toCl = M_EE_BB \\ [pCl_EE; pCl_BB]\nCl_EE, Cl_BB = getblock(Cl, 1), getblock(Cl, 2)","category":"page"},{"location":"spectra/#API","page":"Spectra","title":"API","text":"","category":"section"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"mcm","category":"page"},{"location":"spectra/#PowerSpectra.mcm","page":"Spectra","title":"PowerSpectra.mcm","text":"mcm(spec::Symbol, alm₁::Alm{T}, alm₂::Alm{T}; lmax=nothing)\n\nCompute the mode-coupling matrix. See the Spectral Analysis section in the documentation for examples. These are used by applying the  linear solve operator \\ to a SpectralArray{T,1}.\n\nChoices for spec:\n\n:TT, identical to M⁰⁰\n:TE, identical to :ET, :TB, :BT, :M⁰², :M²⁰\n:EE_BB, returns coupling matrix for stacked EE and BB vectors\n:EB_BE, returns coupling matrix for stacked EB and BE vectors\n:M⁺⁺, sub-block of spin-2 mode-coupling matrices\n:M⁻⁻, sub-block of spin-2 mode-coupling matrices\n\nArguments:\n\nspec::Symbol: cross-spectrum of the mode-coupling matrix\nalm₁::Alm{T}: first mask's spherical harmonic coefficients\nalm₂::Alm{T}: second mask's spherical harmonic coefficients\n\nKeywords\n\nlmin=0: minimum multiple for mode-coupling matrix\nlmax=nothing: maximum multipole for mode-coupling matrix\n\nReturns:\n\nthe mode coupling matrix. for single symbols, this returns a    SpectralArray{T,2}. if spec is :EE_BB or :EB_BE, returns a    BlockSpectralMatrix{T} with 2×2 blocks.\n\n\n\n\n\n","category":"function"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"CurrentModule = PowerSpectra","category":"page"},{"location":"quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/#Temperature","page":"Quickstart","title":"Temperature","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Let's compute some power spectra! For testing convenience, this package includes the  Planck 2018 frequency maps, scaled down to n_mathrmside = 256. These are not  exported by default, so you have to call them with PowerSpectra.planck... names. In this example, we will use the 100 GHz half-mission temperature maps.  We also convert from K_mathrmCMB to mu K_mathrmCMB","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"using Healpix\nusing PowerSpectra\nusing Plots\n\n# retrieve the downgraded planck maps\nnside = 256\nmap1 = 1e6 * PowerSpectra.planck256_map(\"100\", \"hm1\", \"I_STOKES\")\nmap2 = 1e6 * PowerSpectra.planck256_map(\"100\", \"hm2\", \"I_STOKES\")\nplot(map1, clim=(-200,200))","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"We don't want things like the Galaxy and point sources getting in the way. Let's load in the  scaled-down likelihood masks used in the Planck 2018 cosmological analysis. ","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"mask1 = PowerSpectra.planck256_mask(\"100\", \"hm1\", :T)\nmask2 = PowerSpectra.planck256_mask(\"100\", \"hm2\", :T)\nplot(mask1)","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"This mask will be multiplied with our maps to form pseudo-spectra. This removes the Galaxy and the point sources. However, it will bias our  estimate of the spectrum, so we'll have to compute a mode-coupling matrix. Let's do that!","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"The mode-coupling matrix involves the spherical harmonics of the masks. \nThe pseudo-spectrum depends on the spherical harmonics of the masked maps. \nWe wrap the spectrum from Healpix.alm2cl in a SpectralVector in order to tell the    package that this vector represents a power spectrum. Also, it makes it 0-indexed.\nThe important part: we undo the effect of the mask by performing a linear solve.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"# compute the cross-spectra of the masked maps\nmasked_alm_1 = map2alm(map1 * mask1)\nmasked_alm_2 = map2alm(map2 * mask2)\npCl = SpectralVector(alm2cl(masked_alm_1, masked_alm_2))\n\n# compute the mode coupling matrix\nM_TT = mcm(:TT, map2alm(mask1), map2alm(mask2))\n\n# perform a linear solve to undo the effects of mode-coupling\nCl = M_TT \\ pCl","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Now let's plot our spectrum and compare it to the official Planck 2018 bestfit theory. Note that the instrumental beam is also in these maps. This package also provides the  Planck beams as a utility function. We plot these in the convenient scaling, D_ell equiv ell(ell+1) C_ell  2pi.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"# get lmax from nyquist frequency\nlmax = nside2lmax(nside)\n\n# get the planck instrumental beam and pixel window\nWl = PowerSpectra.planck_beam_Wl(\"100\", \"hm1\", \"100\", \"hm2\", :TT, :TT; lmax=lmax)\npixwinT = SpectralVector(pixwin(nside)[1:(lmax+1)])\n\n# plot our spectra\nell = eachindex(Cl)\nprefactor = ell .* (ell .+ 1) ./ (2π)\nplot(prefactor .*  Cl ./ (Wl .* pixwinT.^2), label=\"\\$D_{\\\\ell}\\$\", xlim=(0,2nside) )\n\n# compare it to theory\ntheory = PowerSpectra.planck_theory_Dl()  # returns a Dict of Dl indexed with :TT, :EE, ...\nplot!(theory[:TT], label=\"theory TT\")","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Looks pretty good! ","category":"page"},{"location":"quickstart/#Polarization","page":"Quickstart","title":"Polarization","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"The other common use of this package is to compute every decoupled cross-spectrum between two IQU maps. This is done with the master utility function. We read in the 100 GHz half-mission polarization maps and  masks. We also convert from K_mathrmCMB to mu K_mathrmCMB as before.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"using Healpix\nusing PowerSpectra\nusing Plots\n\nnside = 256\nm₁ = PowerSpectra.planck256_polmap(\"100\", \"hm1\")\nm₂ = PowerSpectra.planck256_polmap(\"100\", \"hm2\")\nmaskT₁ = PowerSpectra.planck256_mask(\"100\", \"hm1\", :T)\nmaskP₁ = PowerSpectra.planck256_mask(\"100\", \"hm1\", :P)\nmaskT₂ = PowerSpectra.planck256_mask(\"100\", \"hm2\", :T)\nmaskP₂ = PowerSpectra.planck256_mask(\"100\", \"hm2\", :P)\n\n# convert to μK\nscale!(m₁, 1e6)\nscale!(m₂, 1e6)\n\nlmax = nside2lmax(256)","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Now we simply call the master utility function with the polarized map,  temperature mask, and polarization mask, for each half-mission. ","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"# utility function for doing TEB mode decoupling\nCl = master(m₁, maskT₁, maskP₁, \n            m₂, maskT₂, maskP₂)\nlmax = nside2lmax(256)\nprint(keys(Cl))","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Let's compare D_ell^TE to the bestfit theory.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"spec = :TE\nWl = PowerSpectra.planck_beam_Wl(\"100\", \"hm1\", \"100\", \"hm2\", spec, spec; lmax=lmax)\npixwinT, pixwinP = pixwin(nside; pol=true)\npixwinT = SpectralVector(pixwinT[1:(lmax+1)])\npixwinP = SpectralVector(pixwinP[1:(lmax+1)])\n\nℓ = eachindex(Wl)\nplot( (ℓ.^2 / (2π)) .*  Cl[spec] ./ (Wl .* pixwinT .* pixwinP), \n    label=\"\\$D_{\\\\ell}\\$\", xlim=(0,2nside) )\ntheory = PowerSpectra.planck_theory_Dl()\nplot!(theory[spec], label=\"theory $(spec)\")","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"We also compare the D_ell^EE to the bestfit theory.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"spec = :EE\nWl = PowerSpectra.planck_beam_Wl(\"100\", \"hm1\", \"100\", \"hm2\", spec, spec; lmax=lmax)\nℓ = eachindex(Wl)\nplot( (ℓ.^2 / (2π)) .*  Cl[spec] ./ (Wl .* pixwinP.^2), \n    label=\"\\$D_{\\\\ell}\\$\", xlim=(0,2nside) )\ntheory = PowerSpectra.planck_theory_Dl()\nplot!(theory[spec], label=\"theory $(spec)\", ylim=(-10,50))","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"CurrentModule = PowerSpectra","category":"page"},{"location":"covariance/#Covariance-Estimation","page":"Covariance","title":"Covariance Estimation","text":"","category":"section"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"The covariance between two spectra textrmCov(hatC_ell^XYij hatC_ell^WZpq) for channels XYWZ in T E obtained from masked maps can be expressed using","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"spherical harmonic coefficients of the masks of the four maps i j p q involved in the covariance\nassumed signal spectrum C_ellmathrmtot^XY, for example C_ell^mathrmth + C_ell^mathrmfgij\npixel variance maps sigma_p^XX for XX in II QQ UU for the four maps involved in the covariance","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"However, these are only sufficient for a description of a homogeneous survey with white noise and sufficient mask apodization. Two additional corrections are required for sim1 covariance determinations.","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"noise power spectra hatN_ell^XYij for the involved channels\ncorrections to the diagonals of the covariance matrices from insufficient apodization around point sources","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"The basic calculation is essentially a mode-coupling calculation, and mode-coupling matrices are themselves used to correct the covariance matrix at the end. The methods in this package were written to match the analysis of the Planck satellite, and we provide a more detailed description of these methods in Li et al. 2020 (in prep). The derivation of these covariance matrices, in the limit of uniform noise, are available in Thibaut Louis's excellent notes.","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"The expressions for the covariance matrix tend to reuse the same expressions many times, and one tends also to compute several different related covariance matrices (i.e. TTTT, TETE, TTTE) on the same maps. The covariance calculation in PowerSpectra.jl is centered around the CovarianceWorkspace, which caches the various quantities that are re-used during covariance estimation.","category":"page"},{"location":"covariance/#Computing-the-Covariance","page":"Covariance","title":"Computing the Covariance","text":"","category":"section"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"First, let's set up the required data – masks and variances. The variance is a Healpix.PolarizedHealpixMap containing the fields i, q, u. In this example, we read the masks from disk, but set the variances for everything to 1.","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"using Healpix, PowerSpectra\nmask1_T = readMapFromFITS(\"test/data/mask1_T.fits\", 1, Float64)\nmask2_T = readMapFromFITS(\"test/data/mask2_T.fits\", 1, Float64)\nmask1_P = readMapFromFITS(\"test/data/mask1_T.fits\", 1, Float64)\nmask2_P = readMapFromFITS(\"test/data/mask2_T.fits\", 1, Float64)\n\n# for this example, pixel variance = 1\nnside = mask1_T.resolution.nside\nunit_var = PolarizedHealpixMap{Float64, RingOrder}(nside)\nunit_var.i .= 1.0\nunit_var.q .= 1.0\nunit_var.u .= 1.0","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"Once you have the masks and variances, you can create a CovField for each field involved. This structure also has an associated name, which is used for the signal spectra.","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"# set up CovField, we're computing the variance of a spectrum on (f1 × f2)\nf1 = CovField(\"143_hm1\", mask1_T, mask1_P, unit_var)\nf2 = CovField(\"143_hm2\", mask2_T, mask2_P, unit_var)\nf3 = f1\nf4 = f2\n\n# compute covariance between the (f1 × f2) spectrum and (f3 × f4) spectrum  \nworkspace = CovarianceWorkspace(f1, f2, f3, f4)","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"A covariance matrix calculation needs an assumed signal spectrum for each channel you want.  You need to generate a dictionary that maps the names of various cross-spectra to SpectralVector.","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"cl_th = SpectralVector(ones(nside2lmax(nside)+1))\n\nspectra = Dict{SpectrumName, SpectralVector{Float64, Vector{Float64}}}(\n    (:TT, \"143_hm1\", \"143_hm1\") => cl_th, (:TT, \"143_hm1\", \"143_hm2\") => cl_th,\n    (:TT, \"143_hm2\", \"143_hm1\") => cl_th, (:TT, \"143_hm2\", \"143_hm2\") => cl_th,\n\n    (:EE, \"143_hm1\", \"143_hm1\") => cl_th, (:EE, \"143_hm1\", \"143_hm2\") => cl_th,\n    (:EE, \"143_hm2\", \"143_hm1\") => cl_th, (:EE, \"143_hm2\", \"143_hm2\") => cl_th ,\n\n    (:TE, \"143_hm1\", \"143_hm1\") => cl_th, (:TE, \"143_hm1\", \"143_hm2\") => cl_th,\n    (:TE, \"143_hm2\", \"143_hm1\") => cl_th, (:TE, \"143_hm2\", \"143_hm2\") => cl_th)","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"Now all that remains is to compute the coupled covmat.","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"C = coupledcov(:TT, :TT, workspace, spectra)","category":"page"},{"location":"covariance/#API","page":"Covariance","title":"API","text":"","category":"section"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"CovField\nCovarianceWorkspace\ncoupledcov","category":"page"},{"location":"covariance/#PowerSpectra.CovField","page":"Covariance","title":"PowerSpectra.CovField","text":"CovField(name, maskT, maskP,\n    σ²II::HealpixMap{T, O, AA}, σ²QQ::HealpixMap{T, O, AA}, σ²UU::HealpixMap{T, O, AA},\n    beamT::SpectralVector{T}, beamP::SpectralVector{T})\n\nCreate a structure for describing the information needed for a covariance involving this field.\n\nArguments:\n\nname::String: name of this field\nmaskT::HealpixMap{T}: temperature mask\nmaskP::HealpixMap{T}: polarization mask\nσ²::PolarizedHealpixMap{T}: pixel variances\nbeamT::SpectralVector{T}: temperature beam\nbeamP::SpectralVector{T}: polarization beam\n\n\n\n\n\n","category":"type"},{"location":"covariance/#PowerSpectra.CovarianceWorkspace","page":"Covariance","title":"PowerSpectra.CovarianceWorkspace","text":"CovarianceWorkspace(m_i, m_j, m_p, m_q; lmax::Int=0)\n\nInputs and cache for covariance calculations. A covariance matrix relates the masks of four fields and spins. This structure caches various cross-spectra between masks and noise-weighted masks.\n\nArguments:\n\nm_i::CovField{T}: map i\nm_j::CovField{T}: map j\nm_p::CovField{T}: map p\nm_q::CovField{T}: map q\n\nKeywords\n\nlmax::Int=0: maximum multipole to compute covariance matrix\n\n\n\n\n\n","category":"type"},{"location":"covariance/#PowerSpectra.coupledcov","page":"Covariance","title":"PowerSpectra.coupledcov","text":"coupledcov(ch1, ch2, workspace, spectra;\n           noiseratios=Dict(), lmax=0) where T\n\nArguments:\n\nch1::Symbol: spectrum type of first spectrum (i.e. :TT, :TE, :EE)\nch2::Symbol: spectrum type of second spectrum (i.e. :TT, :TE, :EE)\nworkspace: cache for working with covariances\nspectra: signal spectra\n\nKeywords\n\nnoiseratios::AbstractDict: ratio of noise spectra to white noise\nlmax=0: maximum multipole moment for covariance matrix\n\nReturns:\n\nSpectralArray{T,2}: covariance matrix (0-indexed)\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PowerSpectra","category":"page"},{"location":"#PowerSpectra","page":"Home","title":"PowerSpectra","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PowerSpectra.jl is a package for power spectrum analysis on the sphere. It computes mode-coupling matrices and covariance matrices for T, E, and B-mode spectra, using pseudo-C_ell methods (i.e. Hivon et al. 2002, Efstathiou 2006, Hamimeche and Lewis 2008). It can also compute  beam matrices in the QuickPol formalism (Hivon et al. 2017).","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package makes use of a special array type, which provides an indexing convention. We provide an introduction and some examples here.","category":"page"},{"location":"#Convention:-SpectralArray-and-SpectralVector","page":"Home","title":"Convention: SpectralArray and SpectralVector","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package wraps outputs in a custom SpectralArray (based on OffsetArray), which provides arbitrary indexing but by default makes an array 0-indexed. This is useful for manipulating angular spectra, as although Julia's indices start at 1, multipoles start with the monopole ell = 0. The type SpectralVector is an alias for a one-dimensional SpectralArray, i.e., SpectralArray{T,1}. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using PowerSpectra\n\njulia> cl = SpectralVector([1,2,3,4])\n4-element SpectralVector{Int64, Vector{Int64}} with indices 0:3:\n 1\n 2\n 3\n 4\n\njulia> cl[0]\n1","category":"page"},{"location":"","page":"Home","title":"Home","text":"The SpectralArray has special operations defined on it, for the manipulation and application of mode-coupling matrices. For the majority of tasks, you will want to have ell_mathrmmin=0, so it's sufficient to just wrap your array without any other arguments, i.e. SpectralArray(A) or SpectralVector(v). For advanced use, take a look at SpectralArray and SpectralVector.","category":"page"},{"location":"util/#SpectralArray-and-SpectralVector","page":"Utilities","title":"SpectralArray and SpectralVector","text":"","category":"section"},{"location":"util/","page":"Utilities","title":"Utilities","text":"This package wraps outputs in a custom SpectralArray (based on OffsetArray), which provides arbitrary indexing but by default makes an array 0-indexed. This is useful for manipulating angular spectra, as although Julia's indices start at 1, multipoles start with the monopole ell = 0. The type SpectralVector is an alias for a one-dimensional SpectralArray, i.e., SpectralArray{T,1}. ","category":"page"},{"location":"util/","page":"Utilities","title":"Utilities","text":"julia> using PowerSpectra\n\njulia> cl = SpectralVector([1,2,3,4])\n4-element SpectralVector{Int64, Vector{Int64}} with indices 0:3:\n 1\n 2\n 3\n 4\n\njulia> cl[0]\n1","category":"page"},{"location":"util/","page":"Utilities","title":"Utilities","text":"You can also specify arbitrary indices, like OffsetArray. In the next example, we index the rows by the range 0:1 and the columns by 5:8.","category":"page"},{"location":"util/","page":"Utilities","title":"Utilities","text":"julia> A = SpectralArray(ones(2,4), 0:1, 5:8)\n2×4 SpectralArray{Float64, 2, Matrix{Float64}} with indices 0:1×5:8:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n\njulia> A[0, 8]\n1.0","category":"page"},{"location":"util/","page":"Utilities","title":"Utilities","text":"Slicing a SpectralArray makes that sliced dimension become 1-indexed, which loses the index information. For example, slicing a SpectraVector just produces a Vector. If you want to produce a SpectralArray that preserves the indices, you can use IdentityRange from IdentityRanges.jl.","category":"page"},{"location":"util/","page":"Utilities","title":"Utilities","text":"julia> x = SpectralVector(ones(4), 0:3)\n4-element SpectralVector{Float64, Vector{Float64}} with indices 0:3:\n 1.0\n 1.0\n 1.0\n 1.0\n\njulia> x[2:3]\n2-element Vector{Float64}:\n 1.0\n 1.0\n\njulia> using IdentityRanges\n\njulia> x[IdentityRange(2:3)]\n2-element SpectralVector{Float64, Vector{Float64}} with indices 2:3:\n 1.0\n 1.0\n","category":"page"},{"location":"util/","page":"Utilities","title":"Utilities","text":"The one major difference is that matrix multiplication and linear solve operator \\ are specialized for the output of mcm.","category":"page"},{"location":"util/","page":"Utilities","title":"Utilities","text":"You can wrap an array A without copying by just calling SpectralArray(A).","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"CurrentModule = PowerSpectra","category":"page"},{"location":"beams/#QuickPol","page":"Beams","title":"QuickPol","text":"","category":"section"},{"location":"beams/","page":"Beams","title":"Beams","text":"We provide utilities to compute beam matrices in the QuickPol formalism (Hivon et al. 2017). We introduce some additional steps here for computational efficiency. In this section, we use the indices ell ell ell such that we don't need to change indices at the end in order to match Hivon. Define a scaled version of the scan spectrum","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"W_ell^nu_1nu_2s_1s_2j_1j_2 = sum_m^prime=-ell^prime^ell^prime  left(_s_1+nu_1tildeomega^(j_1)_ell^prime m^primeright)\n    left(_s_2+nu_2tildeomega^(j_2)_ell^prime m^primeright)^*","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"Define the matrix,","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"beginaligned\nmathbfXi^nu_1nu_2s_1s_2j_1j_2_ell^primeprimeell = (-1)^s_1 + s_2 + nu_1 + nu_2 sum_ell^prime  rho_j_1nu_1 rho_j_2 nu_2  W_ell^nu_1nu_2s_1s_2j_1j_2  \n qquadqquad times beginpmatrix ell  ell^prime  ell^primeprime \n     -s_1  s_1+nu_1   -nu_1 endpmatrix beginpmatrix\n     ell  ell^prime  ell^primeprime  -s_2  s_2+nu_2   -nu_2 endpmatrix\nendaligned","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"This matrix does not depend on u_1 u_2. We can then write the beam matrix in terms of mathbfXi,","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"mathbfB_ell^primeprimeell^nu_1nu_2 u_1 u_2 = sum_j_1 j_2 s_1 s_2 frac2ell + 14pi _u_1hatb^(j_1)*_ell s_1 _u_2hatb^(j_2)*_ell s_2  frack_u_1 k_u_2k_nu_1 k_nu_2  mathbfXi^nu_1nu_2s_1s_2j_1j_2_ell^primeprimeell","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"With this definition, the beam matrices mathbfB are sub-blocks of the linear operator relating the cross-spectrum to the beamed cross-spectrum (Hivon+17 eq. 38),","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"tildeC^nu_1nu_2_ell^primeprime = sum_u_1u_2left(sum_ell mathbfB_ell^primeprimeell^nu_1nu_2 u_1 u_2 C_ell^u_1 u_2 right)","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"Note that the inner sum is just a matrix-vector multiplication.","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"quickpolΞ!\nquickpolW\nkᵤ","category":"page"},{"location":"beams/#PowerSpectra.quickpolΞ!","page":"Beams","title":"PowerSpectra.quickpolΞ!","text":"quickpolΞ!(𝚵::AA, ν₁, ν₂, s₁, s₂, ω₁, ω₂)\n\nThis computes the Xi_ell^prime primeell matrix. It assumes rho has been absorbed into the omega terms.\n\nω₁: effective scan weights with spin s₁ + ν₁\nω₂: effective scan weights with spin s₂ + ν₂\n\n\n\n\n\n","category":"function"},{"location":"beams/#PowerSpectra.quickpolW","page":"Beams","title":"PowerSpectra.quickpolW","text":"quickpolW(alm₁::Alm{Complex{T}}, alm₂::Alm{Complex{T}})\n\nComputes a scaled spectrum of the scan pattern.\n\nW_ell^nu_1nu_2s_1s_2j_1j_2 = sum_m^prime=-ell^prime^ell^prime\n    left(_s_1+nu_1tildeomega^(j_1)_ell^prime m^primeright)\n    left(_s_2+nu_2tildeomega^(j_2)_ell^prime m^primeright)^*\n\n\n\n\n\n","category":"function"},{"location":"beams/#PowerSpectra.kᵤ","page":"Beams","title":"PowerSpectra.kᵤ","text":"kᵤ([T=Float64], u)\n\nDefined only for u ∈ {-2, 0, 2}.\n\n\n\n\n\n","category":"function"}]
}
